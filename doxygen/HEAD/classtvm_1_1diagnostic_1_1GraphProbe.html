<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TVM: tvm::diagnostic::GraphProbe Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="tvmdoxystyle.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TVM
   &#160;<span id="projectnumber">0.8.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classtvm_1_1diagnostic_1_1GraphProbe.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classtvm_1_1diagnostic_1_1GraphProbe-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tvm::diagnostic::GraphProbe Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="GraphProbe_8h_source.html">tvm/diagnostic/GraphProbe.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1diagnostic_1_1GraphProbe_1_1ProbeNode.html">ProbeNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5ada2dd903344cd77c129a1a93a2572b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1diagnostic_1_1GraphProbe.html#a5ada2dd903344cd77c129a1a93a2572b">Output</a> = <a class="el" href="structtvm_1_1graph_1_1internal_1_1Log_1_1Output.html">graph::internal::Log::Output</a></td></tr>
<tr class="separator:a5ada2dd903344cd77c129a1a93a2572b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca1506862bf5686328cb11d8b161574f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1diagnostic_1_1GraphProbe.html#aca1506862bf5686328cb11d8b161574f">Update</a> = <a class="el" href="structtvm_1_1graph_1_1internal_1_1Log_1_1Update.html">graph::internal::Log::Update</a></td></tr>
<tr class="separator:aca1506862bf5686328cb11d8b161574f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68697730bf451a45d1655c7467bfaad6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1diagnostic_1_1GraphProbe.html#a68697730bf451a45d1655c7467bfaad6">OutputVal</a> = std::tuple&lt; <a class="el" href="classtvm_1_1diagnostic_1_1GraphProbe.html#a5ada2dd903344cd77c129a1a93a2572b">Output</a>, <a class="el" href="namespacetvm.html#a024f10de786d6592dbd271d3df847835">VariablePtr</a>, Eigen::MatrixXd &gt;</td></tr>
<tr class="separator:a68697730bf451a45d1655c7467bfaad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:add810a7d49fc14795a0fe5cc6f665b70"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1diagnostic_1_1GraphProbe.html#add810a7d49fc14795a0fe5cc6f665b70">GraphProbe</a> (const <a class="el" href="classtvm_1_1graph_1_1internal_1_1Log.html">graph::internal::Log</a> &amp;log=<a class="el" href="classtvm_1_1graph_1_1internal_1_1Logger.html#a6d18c4d67dcbfc474c12a6600c7d2199">tvm::graph::internal::Logger::logger</a>().log())</td></tr>
<tr class="separator:add810a7d49fc14795a0fe5cc6f665b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3540c5942f5227533ee85e44e42273b8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename MethodT , typename EnumOutput , typename ConvertT  = std::nullopt_t&gt; </td></tr>
<tr class="memitem:a3540c5942f5227533ee85e44e42273b8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtvm_1_1diagnostic_1_1GraphProbe.html#a3540c5942f5227533ee85e44e42273b8">registerAccessor</a> (EnumOutput o, MethodT method, ConvertT convert=std::nullopt)</td></tr>
<tr class="separator:a3540c5942f5227533ee85e44e42273b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f90bd4f2106ad7ebbd1ac6c8b1e5abf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1f90bd4f2106ad7ebbd1ac6c8b1e5abf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtvm_1_1diagnostic_1_1GraphProbe.html#a1f90bd4f2106ad7ebbd1ac6c8b1e5abf">registerTVMFunction</a> ()</td></tr>
<tr class="separator:a1f90bd4f2106ad7ebbd1ac6c8b1e5abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142285352d3869b7f76a1f6796669cd4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a142285352d3869b7f76a1f6796669cd4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtvm_1_1diagnostic_1_1GraphProbe.html#a142285352d3869b7f76a1f6796669cd4">registerTVMConstraint</a> ()</td></tr>
<tr class="separator:a142285352d3869b7f76a1f6796669cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9ae08bbd48ab9ad9f52c3687631a22"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3f9ae08bbd48ab9ad9f52c3687631a22"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtvm_1_1diagnostic_1_1GraphProbe.html#a3f9ae08bbd48ab9ad9f52c3687631a22">registerTVMTaskDynamics</a> ()</td></tr>
<tr class="separator:a3f9ae08bbd48ab9ad9f52c3687631a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050297da6a86f70b0221da554cae7b46"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classtvm_1_1diagnostic_1_1GraphProbe.html#a68697730bf451a45d1655c7467bfaad6">OutputVal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1diagnostic_1_1GraphProbe.html#a050297da6a86f70b0221da554cae7b46">listOutputVal</a> (const <a class="el" href="classtvm_1_1graph_1_1CallGraph.html">graph::CallGraph</a> *const g, bool verbose=false) const</td></tr>
<tr class="separator:a050297da6a86f70b0221da554cae7b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566494aeae79482d00c60d10ed31fc1a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classtvm_1_1diagnostic_1_1GraphProbe.html#a68697730bf451a45d1655c7467bfaad6">OutputVal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1diagnostic_1_1GraphProbe.html#a566494aeae79482d00c60d10ed31fc1a">listOutputVal</a> (const <a class="el" href="classtvm_1_1diagnostic_1_1GraphProbe.html#a5ada2dd903344cd77c129a1a93a2572b">Output</a> &amp;o, bool verbose=false) const</td></tr>
<tr class="separator:a566494aeae79482d00c60d10ed31fc1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a581399d73e52c97de1bd505f9ced99d0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtvm_1_1diagnostic_1_1GraphProbe_1_1ProbeNode.html">ProbeNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1diagnostic_1_1GraphProbe.html#a581399d73e52c97de1bd505f9ced99d0">followUp</a> (const <a class="el" href="classtvm_1_1diagnostic_1_1GraphProbe.html#a5ada2dd903344cd77c129a1a93a2572b">Output</a> &amp;o, const std::function&lt; bool(const Eigen::MatrixXd &amp;)&gt; &amp;select=[](const Eigen::MatrixXd &amp;) { return true;}) const</td></tr>
<tr class="separator:a581399d73e52c97de1bd505f9ced99d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29a143ac0662ceaea1336bfbca8a23e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::unique_ptr&lt; <a class="el" href="structtvm_1_1diagnostic_1_1GraphProbe_1_1ProbeNode.html">ProbeNode</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1diagnostic_1_1GraphProbe.html#ac29a143ac0662ceaea1336bfbca8a23e">followUp</a> (const <a class="el" href="classtvm_1_1graph_1_1CallGraph.html">graph::CallGraph</a> *const g, const std::function&lt; bool(const Eigen::MatrixXd &amp;)&gt; &amp;select=[](const Eigen::MatrixXd &amp;) { return true;}) const</td></tr>
<tr class="separator:ac29a143ac0662ceaea1336bfbca8a23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11cd63affa1b99e0e93ee28a88828c2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1diagnostic_1_1GraphProbe.html#a11cd63affa1b99e0e93ee28a88828c2c">print</a> (std::ostream &amp;os, const std::unique_ptr&lt; <a class="el" href="structtvm_1_1diagnostic_1_1GraphProbe_1_1ProbeNode.html">ProbeNode</a> &gt; &amp;root) const</td></tr>
<tr class="separator:a11cd63affa1b99e0e93ee28a88828c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3026de38c57669c10390785c00cb5ebc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1diagnostic_1_1GraphProbe.html#a3026de38c57669c10390785c00cb5ebc">print</a> (std::ostream &amp;os, const std::vector&lt; std::unique_ptr&lt; <a class="el" href="structtvm_1_1diagnostic_1_1GraphProbe_1_1ProbeNode.html">ProbeNode</a> &gt;&gt; &amp;roots) const</td></tr>
<tr class="separator:a3026de38c57669c10390785c00cb5ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a364d4912cdacd202d4e7a0c43e9cedd8"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1diagnostic_1_1GraphProbe.html#a364d4912cdacd202d4e7a0c43e9cedd8">absInRange</a></td></tr>
<tr class="separator:a364d4912cdacd202d4e7a0c43e9cedd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7800e5b2c6152f94de5a5a2d965b03f5"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1diagnostic_1_1GraphProbe.html#a7800e5b2c6152f94de5a5a2d965b03f5">hasNan</a> = [](const Eigen::MatrixXd &amp; M) { return M.hasNaN(); }</td></tr>
<tr class="separator:a7800e5b2c6152f94de5a5a2d965b03f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class to explore the value computed in a call graph.</p>
<p>Because the tvm nodes only declare the dependencies between inputs, updates and outputs, but not the way to retrieve an output, it is necessary to register first the method used to access each output of interest. This is done atomically with the methods <code>GraphNode::registerAccessor</code>, or at higher level with the methods <code>GraphNode::registerTVMFunction</code>, <code>GraphNode::registerTVMConstraint</code> and <code>GraphNode::registerTVMTaskDynamics</code>. Access methods for base tvm classes are automatically registered in the constructor. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a5ada2dd903344cd77c129a1a93a2572b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ada2dd903344cd77c129a1a93a2572b">&#9670;&nbsp;</a></span>Output</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtvm_1_1diagnostic_1_1GraphProbe.html#a5ada2dd903344cd77c129a1a93a2572b">tvm::diagnostic::GraphProbe::Output</a> =  <a class="el" href="structtvm_1_1graph_1_1internal_1_1Log_1_1Output.html">graph::internal::Log::Output</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a68697730bf451a45d1655c7467bfaad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68697730bf451a45d1655c7467bfaad6">&#9670;&nbsp;</a></span>OutputVal</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtvm_1_1diagnostic_1_1GraphProbe.html#a68697730bf451a45d1655c7467bfaad6">tvm::diagnostic::GraphProbe::OutputVal</a> =  std::tuple&lt;<a class="el" href="classtvm_1_1diagnostic_1_1GraphProbe.html#a5ada2dd903344cd77c129a1a93a2572b">Output</a>, <a class="el" href="namespacetvm.html#a024f10de786d6592dbd271d3df847835">VariablePtr</a>, Eigen::MatrixXd&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aca1506862bf5686328cb11d8b161574f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca1506862bf5686328cb11d8b161574f">&#9670;&nbsp;</a></span>Update</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtvm_1_1diagnostic_1_1GraphProbe.html#aca1506862bf5686328cb11d8b161574f">tvm::diagnostic::GraphProbe::Update</a> =  <a class="el" href="structtvm_1_1graph_1_1internal_1_1Log_1_1Update.html">graph::internal::Log::Update</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="add810a7d49fc14795a0fe5cc6f665b70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add810a7d49fc14795a0fe5cc6f665b70">&#9670;&nbsp;</a></span>GraphProbe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tvm::diagnostic::GraphProbe::GraphProbe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1graph_1_1internal_1_1Log.html">graph::internal::Log</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="classtvm_1_1graph_1_1internal_1_1Logger.html#a6d18c4d67dcbfc474c12a6600c7d2199">tvm::graph::internal::Logger::logger</a>().log()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a581399d73e52c97de1bd505f9ced99d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a581399d73e52c97de1bd505f9ced99d0">&#9670;&nbsp;</a></span>followUp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="structtvm_1_1diagnostic_1_1GraphProbe_1_1ProbeNode.html">ProbeNode</a>&gt; tvm::diagnostic::GraphProbe::followUp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1diagnostic_1_1GraphProbe.html#a5ada2dd903344cd77c129a1a93a2572b">Output</a> &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const Eigen::MatrixXd &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>select</em> = <code>[](const&#160;Eigen::MatrixXd&#160;&amp;)&#160;{&#160;return&#160;true;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Follow up backward the computation graph starting at node <code>o</code>, and trimming out branches where the value of an output does not pass the test given by <code>select</code>. </p>

</div>
</div>
<a id="ac29a143ac0662ceaea1336bfbca8a23e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac29a143ac0662ceaea1336bfbca8a23e">&#9670;&nbsp;</a></span>followUp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::unique_ptr&lt;<a class="el" href="structtvm_1_1diagnostic_1_1GraphProbe_1_1ProbeNode.html">ProbeNode</a>&gt; &gt; tvm::diagnostic::GraphProbe::followUp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1graph_1_1CallGraph.html">graph::CallGraph</a> *const&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const Eigen::MatrixXd &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>select</em> = <code>[](const&#160;Eigen::MatrixXd&#160;&amp;)&#160;{&#160;return&#160;true;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Follow up backward the computation graph starting at the inputs of <code>g</code>, and trimming out branches where the value of an output does not pass the test given by <code>select</code>. </p>

</div>
</div>
<a id="a050297da6a86f70b0221da554cae7b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a050297da6a86f70b0221da554cae7b46">&#9670;&nbsp;</a></span>listOutputVal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classtvm_1_1diagnostic_1_1GraphProbe.html#a68697730bf451a45d1655c7467bfaad6">OutputVal</a>&gt; tvm::diagnostic::GraphProbe::listOutputVal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1graph_1_1CallGraph.html">graph::CallGraph</a> *const&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>List all the values of all the outputs present in the call graph <code>g</code> (if the associated methods were registered).</p>
<p>If <code>verbose</code> is <code>true</code>, display the outputs for which no methods were registered to retrieve their values. </p>

</div>
</div>
<a id="a566494aeae79482d00c60d10ed31fc1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a566494aeae79482d00c60d10ed31fc1a">&#9670;&nbsp;</a></span>listOutputVal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classtvm_1_1diagnostic_1_1GraphProbe.html#a68697730bf451a45d1655c7467bfaad6">OutputVal</a>&gt; tvm::diagnostic::GraphProbe::listOutputVal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1diagnostic_1_1GraphProbe.html#a5ada2dd903344cd77c129a1a93a2572b">Output</a> &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>List all the values of all the outputs on which <code>o</code> depends (recursively) (if the associated methods were registered).</p>
<p>If <code>verbose</code> is <code>true</code>, display the outputs for which no methods were registered to retrieve their values. </p>

</div>
</div>
<a id="a11cd63affa1b99e0e93ee28a88828c2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11cd63affa1b99e0e93ee28a88828c2c">&#9670;&nbsp;</a></span>print() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::diagnostic::GraphProbe::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unique_ptr&lt; <a class="el" href="structtvm_1_1diagnostic_1_1GraphProbe_1_1ProbeNode.html">ProbeNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print in <code>os</code> the tree starting at <code>root</code>. </p>

</div>
</div>
<a id="a3026de38c57669c10390785c00cb5ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3026de38c57669c10390785c00cb5ebc">&#9670;&nbsp;</a></span>print() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::diagnostic::GraphProbe::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::unique_ptr&lt; <a class="el" href="structtvm_1_1diagnostic_1_1GraphProbe_1_1ProbeNode.html">ProbeNode</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>roots</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print in <code>os</code> the trees starting each at an element of <code>root</code>. </p>

</div>
</div>
<a id="a3540c5942f5227533ee85e44e42273b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3540c5942f5227533ee85e44e42273b8">&#9670;&nbsp;</a></span>registerAccessor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename MethodT , typename EnumOutput , typename ConvertT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::diagnostic::GraphProbe::registerAccessor </td>
          <td>(</td>
          <td class="paramtype">EnumOutput&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MethodT&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConvertT&#160;</td>
          <td class="paramname"><em>convert</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register a method <code>fn</code> to retrieve the value associated to <code>o</code> </p>
<p>The method either takes a variable or does not</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the node to which the method is attached. It must be given explicitly if the method is inherited from a base class, otherwise the method will be registered for this base class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a142285352d3869b7f76a1f6796669cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142285352d3869b7f76a1f6796669cd4">&#9670;&nbsp;</a></span>registerTVMConstraint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::diagnostic::GraphProbe::registerTVMConstraint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register all methods associated to outputs inherited from <a class="el" href="classtvm_1_1constraint_1_1abstract_1_1Constraint.html">tvm::constraint::abstract::Constraint</a> </p>

</div>
</div>
<a id="a1f90bd4f2106ad7ebbd1ac6c8b1e5abf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f90bd4f2106ad7ebbd1ac6c8b1e5abf">&#9670;&nbsp;</a></span>registerTVMFunction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::diagnostic::GraphProbe::registerTVMFunction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register all methods associated to outputs inherited from <a class="el" href="classtvm_1_1function_1_1abstract_1_1Function.html">tvm::function::abstract::Function</a> </p>

</div>
</div>
<a id="a3f9ae08bbd48ab9ad9f52c3687631a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f9ae08bbd48ab9ad9f52c3687631a22">&#9670;&nbsp;</a></span>registerTVMTaskDynamics()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::diagnostic::GraphProbe::registerTVMTaskDynamics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register all methods associated to outputs inherited from <a class="el" href="classtvm_1_1task__dynamics_1_1abstract_1_1TaskDynamicsImpl.html">tvm::task_dynamics::abstract::TaskDynamicsImpl</a> </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a364d4912cdacd202d4e7a0c43e9cedd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a364d4912cdacd202d4e7a0c43e9cedd8">&#9670;&nbsp;</a></span>absInRange</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto tvm::diagnostic::GraphProbe::absInRange</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keywordtype">double</span> rmin, <span class="keywordtype">double</span> rmax) {</div><div class="line">    <span class="keywordflow">return</span> [rmin, rmax](<span class="keyword">const</span> Eigen::MatrixXd &amp; M) { <span class="keywordflow">return</span> <a class="code" href="namespacetvm_1_1diagnostic.html#a6bc3dc6b84828a42cd9f1dc98775636f">hasElemAbsInRange</a>(M, rmin, rmax); };</div><div class="line">  }</div></div><!-- fragment --><p>Factory returning a function checking if a matrix M has elements whose absolute value is between <code>rmin</code> and <code>rmax</code>.</p>
<p>This function can be used as a select function in <code><a class="el" href="classtvm_1_1diagnostic_1_1GraphProbe.html#a581399d73e52c97de1bd505f9ced99d0">GraphProbe::followUp</a></code>. </p>

</div>
</div>
<a id="a7800e5b2c6152f94de5a5a2d965b03f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7800e5b2c6152f94de5a5a2d965b03f5">&#9670;&nbsp;</a></span>hasNan</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto tvm::diagnostic::GraphProbe::hasNan = [](const Eigen::MatrixXd &amp; M) { return M.hasNaN(); }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function checking if <code>M</code> contains NaN.</p>
<p>This function can be used as a select function in <code><a class="el" href="classtvm_1_1diagnostic_1_1GraphProbe.html#a581399d73e52c97de1bd505f9ced99d0">GraphProbe::followUp</a></code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/tvm/diagnostic/<a class="el" href="GraphProbe_8h_source.html">GraphProbe.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacetvm.html">tvm</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1diagnostic.html">diagnostic</a></li><li class="navelem"><a class="el" href="classtvm_1_1diagnostic_1_1GraphProbe.html">GraphProbe</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
