<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TVM: How to create new TVM functions.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/SVG"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="tvmdoxystyle.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TVM
   &#160;<span id="projectnumber">0.8.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a02450.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">How to create new TVM functions. </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>Preliminaries </h1>
<p>In this example, we will be creating a <em>dot product</em> function between two variables.</p>
<p>Let's consider two variables \( x \) and \( y \) with the same size, and let's define the function \( f(x,y) = x^T y \). The partial derivatives of this function with respect to \( x \) and \( y \) are</p>
<p>\( J_x = \frac{\partial f}{\partial x} = y^T \ \ \mbox{and}\ \ J_y = \frac{\partial f}{\partial y} = x^T \quad (1) \)</p>
<p>If now \( x \) and \( y \) are themselves function of the time \( t \), then we have</p>
<p>\( \dot{f} = \dot{x}^T y + x^T \dot{y} \quad (2) \)</p>
<p>Given a function \( g(q) \), with Jacobian matrix \( J \), we call <em>normal acceleration</em> the term \( \gamma = \dot{J}\dot{q} \). It appears when computing the acceleration of \( g(q) \): \( \ddot{g}(q) = J \ddot{q} + \dot{J}\dot{q} \) ( \( J \ddot{q} \) is in the tangent space to \( g(q(t)) \). <br />
 For the dot product, we have</p>
<p>\( \gamma = 2 \dot{x}^T \dot{y} \quad (3) \)</p>
<p>We can also directly take the derivative of the Jacobian matrices:</p>
<p>\( \dot{J}_x = \dot{y}^T \ \ \mbox{and}\ \ \dot{J}_y = \dot{x}^T \quad (4) \)</p>
<h1>Implementation outline </h1>
<p>A TVM function is an object able to return the value of a mathematical function \( f \) and some of its derivatives, given the values of the variables \( x_i \) it depends on. It is implemented by creating a class inheriting from <a class="el" href="a01053.html" title="Base class defining the classical outputs for a function. ">tvm::function::abstract::Function</a>.</p>
<p>Under the hood, TVM is making use of a <em>computation graph</em>, that is a set of computation units whose inputs and outputs are connected in some way. A <a class="el" href="a01053.html" title="Base class defining the classical outputs for a function. ">tvm::function::abstract::Function</a> is meant to be a set of computation units and pre-defines 5 outputs, accessible through 5 methods, as summarized in the following table:</p>
<table class="doxtable">
<tr>
<th align="center">output id </th><th align="center">mathematical meaning </th><th align="center">returned by </th><th align="center">cache member (type)  </th></tr>
<tr>
<td align="center"><code>Output::Value</code> </td><td align="center">\( f(x_1, \ldots x_n) \) </td><td align="center"><code>value()</code> </td><td align="center"><code>value_</code> (VectorXd) </td></tr>
<tr>
<td align="center"><code>Output::Jacobian</code> </td><td align="center">\( \frac{\partial f}{\partial x_i} \) </td><td align="center"><code>jacobian(xi)</code> </td><td align="center"><code>jacobian_</code> (map of MatrixXd) </td></tr>
<tr>
<td align="center"><code>Output::Velocity</code> </td><td align="center">\( \dot{f}(x_1, \ldots x_n) \) </td><td align="center"><code>velocity()</code> </td><td align="center"><code>velocity_</code> (VectorXd) </td></tr>
<tr>
<td align="center"><code>Output::NormalAcceleration</code> </td><td align="center">\( \sum \dot{J}_{x_i} \dot{x}_i \) </td><td align="center"><code>normalAcceleration(xi)</code> </td><td align="center"><code>normalAcceleration_</code> (VectorXd) </td></tr>
<tr>
<td align="center"><code>Output::JDot</code> </td><td align="center">\( \frac{d}{dt}\frac{\partial f}{\partial x_i} \) </td><td align="center"><code>JDot(xi)</code> </td><td align="center"><code>JDot_</code> (map of MatrixXd) </td></tr>
</table>
<p>To avoid duplicated computations, the output values are cached. The update of these cached values is done by <em>update methods</em> that will be called when needed and in the correct order. The names of the pre-defined cache members are given in the above table. <br />
 The core of implementing a new TVM function consists thus in two steps:</p><ul>
<li>declaring the update methods and their relations to the inputs, outputs and in some cases other update methods</li>
<li>implementing these methods</li>
</ul>
<p>An update method may update several outputs, or be used by other update methods.</p>
<p>We will implement a class <code>DotProduct</code> with the following update methods:</p><ul>
<li><code>updateValue</code>, updating <code>value_</code> </li>
<li><code>updateJacobian</code>, updating <code>jacobian_</code> </li>
<li><code>updateVelocityAndNormalAcc</code>, updating <code>velocity_</code> and <code>normalAcceleration_</code> </li>
<li><code>updateJDot</code>, updating <code>JDot_</code> </li>
</ul>
<p>Grouping the updates of the velocity and the normal acceleration can often make sense, because these quantities are often used in the same context in robotic control. Here we also do it for showing the possibility.</p>
<h1>Implemetation details </h1>
<h2>Class declaration </h2>
<p>The class is defined as follows  <pre><div class="fragment"><div class="line"><span class="keyword">class </span>DotProduct : <span class="keyword">public</span> function::abstract::Function</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <a class="code" href="a00068.html#abd38cd98a6567962387d6ebe5a27ce45">SET_UPDATES</a>(DotProduct, Value, Jacobian, VelocityAndNormalAcc, JDot)</div><div class="line"></div><div class="line">  DotProduct(<a class="code" href="a00395.html#a024f10de786d6592dbd271d3df847835">VariablePtr</a> x, <a class="code" href="a00395.html#a024f10de786d6592dbd271d3df847835">VariablePtr</a> y);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> updateValue();</div><div class="line">  <span class="keywordtype">void</span> updateJacobian();</div><div class="line">  <span class="keywordtype">void</span> updateVelocityAndNormalAcc();</div><div class="line">  <span class="keywordtype">void</span> updateJDot();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  Variable &amp; x_;</div><div class="line">  Variable &amp; y_;</div><div class="line">  Variable &amp; dx_;</div><div class="line">  Variable &amp; dy_;</div><div class="line">};</div></div><!-- fragment -->
</pre><p>With the <code>SET_UPDATES</code> macro, we are defining identifiers for the update methods. The first argument needs to be the class name, the other are the identifiers and can be chosen freely. <br />
 <code>SET_UPDATES</code> is performing several tasks necessary for the computation graph machinery, including creating an enumeration class-like DotProduct::Update, whose elements are <code>Value</code>, <code>Jacobian</code>, <code>VelocityAndNormalAcc</code> and <code>JDot</code>.</p>
<p>The constructor of the class simply takes (shared) pointers on the variables <code>x</code> and <code>y</code>. Then comes the 4 update methods we want to define. Their names are free, but it is good practice to use the pattern <code>updateID</code>, where ID is the identifier chosen in <code>SET_UPDATES</code>.</p>
<p>Finally, we declare four references on the variables <code>x</code>, <code>y</code> and their first derivatives. These are merely convenience members, as the variables can be accessed through the <code>variables_</code> member, inherited from <a class="el" href="a01053.html" title="Base class defining the classical outputs for a function. ">tvm::function::abstract::Function</a>.</p>
<h2>Constructor </h2>
<p>Three characteristics of the function should be specified before it is used and this should generally be done in the constructor:</p><ul>
<li>the size of its value \( f(x_1, \ldots x_n) \), what TVM refers to as the <em>size</em> of the function (1 in our <code>DotProduct</code> example)</li>
<li>the variables it depends on</li>
<li>its internal computation graph</li>
</ul>
<p>The size is passed as an argument to the base <a class="el" href="a01053.html" title="Base class defining the classical outputs for a function. ">tvm::function::abstract::Function</a> constructor. <br />
 The variables are specified by the <code>addVariable</code> method. <br />
 For functions that depend only on their variables, and not on other functions or computation nodes, the internal computation graph is described by</p><ul>
<li><code>registerUpdates</code>, which takes pairs of (update id, pointer to the corresponding update method), to register the existing update methods</li>
<li><code>addOutputDependency</code> which takes an output id (or a list of them) and a update id, to specify that the given output(s) is (/are) updated by the corresponding update method. In case an update method relies on the computation of another one, the dependency is declared with <code>addInternalDependency</code>.</li>
</ul>
<p>The code of our constructor is </p><pre><div class="fragment"><div class="line">DotProduct::DotProduct(<a class="code" href="a00395.html#a024f10de786d6592dbd271d3df847835">VariablePtr</a> x, <a class="code" href="a00395.html#a024f10de786d6592dbd271d3df847835">VariablePtr</a> y) : Function(1), x_(*x), y_(*y), dx_(*<a class="code" href="a00395.html#a87d6cb6ff8019ac998b40578d2a27438">dot</a>(x)), dy_(*<a class="code" href="a00395.html#a87d6cb6ff8019ac998b40578d2a27438">dot</a>(y))</div><div class="line">{</div><div class="line">  <span class="comment">// clang-format off</span></div><div class="line">    registerUpdates(Update::Value, &amp;DotProduct::updateValue,</div><div class="line">      Update::Jacobian, &amp;DotProduct::updateJacobian,</div><div class="line">      Update::VelocityAndNormalAcc, &amp;DotProduct::updateVelocityAndNormalAcc,</div><div class="line">      Update::JDot, &amp;DotProduct::updateJDot);</div><div class="line">  <span class="comment">// clang-format on</span></div><div class="line">  addOutputDependency&lt;DotProduct&gt;(Output::Value, Update::Value);</div><div class="line">  addOutputDependency&lt;DotProduct&gt;(Output::Jacobian, Update::Jacobian);</div><div class="line">  addOutputDependency&lt;DotProduct&gt;({Output::Velocity, Output::NormalAcceleration}, Update::VelocityAndNormalAcc);</div><div class="line">  addOutputDependency&lt;DotProduct&gt;(Output::JDot, Update::JDot);</div><div class="line">  addVariable(x, <span class="keyword">true</span>);</div><div class="line">  addVariable(y, <span class="keyword">true</span>);</div><div class="line">}</div></div><!-- fragment -->
</pre><p> <code>Function(1)</code> is the specification of the function size. <br />
 The references are initialized from the shared pointer to the adequate variables. Those variables lifetime is ensured, because the function will keep track of them through the calls to <code>addVariable</code>. <br />
 The call to <code>registerUpdate</code> associates the id <code>Update::Value</code> with the update method <code>updateValue</code>, the id <code>Update::Jacobian</code> with the method <code>updateJacobian</code>, ... <br />
 The first call to <code>addOutputDependency</code> declares that the output with id <code>Output::Value</code> is updated by the update method associated to id <code>Update::Value</code>. The third call shows how to associate two outputs to a single update. Registering update methods must be done before calling <code>addDependencies</code> between outputs and updates. <br />
 Finally, <code>x</code> and <code>y</code> are added as variables of the function through the calls to <code>addVariable</code>. The second argument, set to <code>true</code>, means that the function linearly depends on those variables.</p>
<h2>Update methods </h2>
<p>The implementation of the four update methods is a direct transcription of the mathematical expression. </p><pre><div class="fragment"><div class="line"><span class="keywordtype">void</span> DotProduct::updateValue() { value_ = x_.value().transpose() * y_.value(); }</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> DotProduct::updateJacobian()</div><div class="line">{</div><div class="line">  jacobian_.at(&amp;x_) = y_.value().transpose();</div><div class="line">  jacobian_.at(&amp;y_) = x_.value().transpose();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> DotProduct::updateVelocityAndNormalAcc()</div><div class="line">{</div><div class="line">  velocity_ = dx_.value().transpose() * y_.value() + x_.value().transpose() * dy_.value();</div><div class="line">  normalAcceleration_ = 2 * dx_.value().transpose() * dy_.value();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> DotProduct::updateJDot()</div><div class="line">{</div><div class="line">  JDot_.at(&amp;x_) = dy_.value().transpose();</div><div class="line">  JDot_.at(&amp;y_) = dx_.value().transpose();</div><div class="line">}</div></div><!-- fragment -->
</pre><p> Members <code>jacobian_</code> and <code>JDot_</code> are <code>std::map</code> indexed by the variables.</p>
<h2>Example of use </h2>
<p>See <a class="el" href="a02450.html#exampleFile">Example file </a> below.</p>
<h2>Remarks </h2>
<ul>
<li>Cache members automatically have the correct size: this is ensured at construction time or when <code>addVariable</code> is used. It is the responsibility of the user to not change those sizes.</li>
<li>The constructor should of course check that both variables have the same size.</li>
</ul>
<h1>Advanced example </h1>
<p>So far, we saw the implementation of a rather simple function, that only depends on its variables. We present here an extension that requires a more complexe use of the computation graph.</p>
<p>Instead of considering the dot product between two variables, we will now take the dot product of two functions. This will be done by implementing a class <code>FunctionDotProduct</code>.</p>
<h2>Formulas </h2>
<p>Given two functions \( g \) and \( h \), we are considering the function \( f = g^T h \).</p>
<p>We have that</p>
<p>\( \begin{align} &amp;\frac{\partial f}{\partial x_i} = g^T \frac{\partial h}{\partial x_i} + h^T \frac{\partial g}{\partial x_i} \\ &amp;\dot{f} = g^T \dot{h} + \dot{g}^T h \\ &amp;\gamma_f = 2 \dot{g}^T \dot{h} + g^T \gamma_h + h^T \gamma_g \end{align} \)</p>
<h2>Class declaration </h2>
<p>The <code>FunctionDotProduct</code> class can be defined as follows </p><pre><div class="fragment"><div class="line"><span class="keyword">class </span>FunctionDotProduct : <span class="keyword">public</span> graph::abstract::OutputSelector&lt;function::abstract::Function&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <a class="code" href="a00059.html#af3c088e8f82f2660e01a45bb8eb92ebf">DISABLE_OUTPUTS</a>(Output::JDot)</div><div class="line">  <a class="code" href="a00068.html#abd38cd98a6567962387d6ebe5a27ce45">SET_UPDATES</a>(FunctionDotProduct, Value, Jacobian, Velocity, NormalAcc)</div><div class="line"></div><div class="line">  FunctionDotProduct(<a class="code" href="a00395.html#a42313833bbb66bf5318f67e0dca5936a">FunctionPtr</a> g, <a class="code" href="a00395.html#a42313833bbb66bf5318f67e0dca5936a">FunctionPtr</a> h);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> updateValue();</div><div class="line">  <span class="keywordtype">void</span> updateJacobian();</div><div class="line">  <span class="keywordtype">void</span> updateVelocity();</div><div class="line">  <span class="keywordtype">void</span> updateNormalAcc();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="comment">// Register the inputs and update, and specify the dependencies output &lt;- update &lt;- inputs</span></div><div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Out, <span class="keyword">typename</span> Up, <span class="keyword">typename</span>... In&gt;</div><div class="line">  <span class="keywordtype">void</span> processOutput(Out output, Up u, <span class="keywordtype">void</span> (FunctionDotProduct::*update)(), In... inputs);</div><div class="line"></div><div class="line">  <a class="code" href="a00395.html#a42313833bbb66bf5318f67e0dca5936a">FunctionPtr</a> g_;</div><div class="line">  <a class="code" href="a00395.html#a42313833bbb66bf5318f67e0dca5936a">FunctionPtr</a> h_;</div><div class="line">};</div></div><!-- fragment -->
</pre><p> There are two important differences with what we did before, both of which related to enabling/disabling outputs. Disabled outputs can not be used in the computation graph, and there are no need to implement update methods for them.</p>
<p>First, the class does not derive directly from <a class="el" href="a01053.html" title="Base class defining the classical outputs for a function. ">tvm::function::abstract::Function</a> but from tvm::graph::abstract::OutputSelector&lt;function::abstract::Function&gt; (which in turn derives from <a class="el" href="a01053.html" title="Base class defining the classical outputs for a function. ">tvm::function::abstract::Function</a>). This allows to enable or disable outputs of the class <em>at runtime</em>: depending on the outputs available for functions \( g \) and \( h \), we might not be able to compute all the outputs of our function.</p>
<p>Second, we are using the macro <code>DISABLE_OUTPUTS</code> to disable <em>statically</em> the <code>JDot</code> output. There are several reasons for disabling outputs this way, most notably the fact that one cannot or does not want to implement the computations for an output. <br />
 Calling <code>DISABLE_OUTPUTS</code> is independent of using graph::abstract::OutputSelector.</p>
<p>Otherwise, the class has four update methods, and keep a pointer on <code>g</code> and <code>h</code>. We also have a helper function, <code>processOutput</code>, whose role is to check that <code>g</code> and <code>h</code> have the required outputs for computing a given output of our function, and if so make the adequate registrations and dependency declarations.</p>
<h2>Constructor </h2>
<p>The constructor is doing the same job as before: specifying the size of the function (this time through <a class="el" href="a01097.html" title="This class adds to its template argument the capability to enable or disable some of its outputs...">tvm::graph::abstract::OutputSelector</a>), creating the internal computation graph, and adding the variables the function depends on. </p><pre><div class="fragment"><div class="line">FunctionDotProduct::FunctionDotProduct(<a class="code" href="a00395.html#a42313833bbb66bf5318f67e0dca5936a">FunctionPtr</a> g, <a class="code" href="a00395.html#a42313833bbb66bf5318f67e0dca5936a">FunctionPtr</a> h)</div><div class="line">: graph::abstract::OutputSelector&lt;function::abstract::Function&gt;(1), g_(g), h_(h)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span>(!g-&gt;imageSpace().isEuclidean() || !h-&gt;imageSpace().isEuclidean())</div><div class="line">    <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Function g and h must have their values in an Euclidean space.&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span>(g-&gt;size() != h-&gt;size())</div><div class="line">    <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Function g and h must have the same size&quot;</span>);</div><div class="line"></div><div class="line">  processOutput(Output::Value, Update::Value, &amp;FunctionDotProduct::updateValue, Output::Value);</div><div class="line">  processOutput(Output::Jacobian, Update::Jacobian, &amp;FunctionDotProduct::updateJacobian, Output::Value,</div><div class="line">                Output::Jacobian);</div><div class="line">  processOutput(Output::Velocity, Update::Velocity, &amp;FunctionDotProduct::updateVelocity, Output::Value,</div><div class="line">                Output::Velocity);</div><div class="line">  processOutput(Output::NormalAcceleration, Update::NormalAcc, &amp;FunctionDotProduct::updateNormalAcc, Output::Value,</div><div class="line">                Output::Velocity, Output::NormalAcceleration);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp; xi : g_-&gt;variables())</div><div class="line">  {</div><div class="line">    <span class="keywordtype">bool</span> lin = g_-&gt;linearIn(*xi) &amp;&amp; !h_-&gt;variables().contains(*xi);</div><div class="line">    addVariable(xi, lin);</div><div class="line">  }</div><div class="line">  <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp; xi : h_-&gt;variables())</div><div class="line">  {</div><div class="line">    <span class="keywordtype">bool</span> lin = h_-&gt;linearIn(*xi) &amp;&amp; !g_-&gt;variables().contains(*xi);</div><div class="line">    addVariable(xi, lin);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment -->
</pre><p> The creation of the graph is using the method <code>processOutput</code> described below. The following table shows the dependency flow:</p>
<table class="doxtable">
<tr>
<th align="center">outputs of g and h </th><th align="center">update id </th><th align="center">output of f  </th></tr>
<tr>
<td align="center"><code>Output::Value</code> </td><td align="center"><code>Update::Value</code> </td><td align="center"><code>Output::Value</code> </td></tr>
<tr>
<td align="center"><code>Output::Value</code> </td><td align="center"><code>Update::Jacobian</code> </td><td align="center"><code>Output::Jacobian</code> </td></tr>
<tr>
<td align="center"><code>Output::Jacobian</code> </td><td align="center">^ </td><td align="center">^ </td></tr>
<tr>
<td align="center"><code>Output::Value</code> </td><td align="center"><code>Update::Velocity</code> </td><td align="center"><code>Output::Velocity</code> </td></tr>
<tr>
<td align="center"><code>Output::Velocity</code> </td><td align="center">^ </td><td align="center">^ </td></tr>
<tr>
<td align="center"><code>Output::Value</code> </td><td align="center"><code>Update::NormalAcc</code> </td><td align="center"><code>Output::NormalAcceleration</code> </td></tr>
<tr>
<td align="center"><code>Output::Velocity</code> </td><td align="center">^ </td><td align="center">^ </td></tr>
<tr>
<td align="center"><code>Output::NormalAcceleration</code> </td><td align="center">^ </td><td align="center">^ </td></tr>
</table>
<p>An output of our function can be enabled only if the required output of <code>g</code> and <code>h</code> are available.</p>
<p>Lastly, we add to our function the variables of <code>g</code> and <code>h</code>. Adding a second time the same variable has no effect, so that we do not need to check what variables are shared among <code>g</code> and <code>h</code>. To do things properly, we need to determine if a variable of our function will appear linearly. This is the case if it appears linearly in <code>g</code> or <code>h</code> and does not appear in the other.</p>
<h2>Methods implementation </h2>
<p>The update methods are straigtforward transcription of the mathematical formulas. </p><pre><div class="fragment"><div class="line"><span class="keywordtype">void</span> FunctionDotProduct::updateValue() { value_ = g_-&gt;value().transpose() * h_-&gt;value(); }</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> FunctionDotProduct::updateJacobian()</div><div class="line">{</div><div class="line">  <span class="comment">// We reset all the jacobian matrices (we could do that only for those corresponding to variable of h)</span></div><div class="line">  <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp; xi : variables_)</div><div class="line">  {</div><div class="line">    jacobian_.at(xi.get()).setZero();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp; xi : g_-&gt;variables())</div><div class="line">  {</div><div class="line">    jacobian_.at(xi.get()) = h_-&gt;value().transpose() * g_-&gt;jacobian(*xi);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// We use += here, because if a variable is also present in g, we need to add to the previously copied jacobian matrix</span></div><div class="line">  <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp; xi : h_-&gt;variables())</div><div class="line">  {</div><div class="line">    jacobian_.at(xi.get()) += g_-&gt;value().transpose() * h_-&gt;jacobian(*xi);</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> FunctionDotProduct::updateVelocity()</div><div class="line">{</div><div class="line">  velocity_ = g_-&gt;value().transpose() * h_-&gt;velocity() + g_-&gt;velocity().transpose() * h_-&gt;value();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> FunctionDotProduct::updateNormalAcc()</div><div class="line">{</div><div class="line">  normalAcceleration_ = 2 * g_-&gt;velocity().transpose() * h_-&gt;velocity()</div><div class="line">                        + g_-&gt;value().transpose() * h_-&gt;normalAcceleration()</div><div class="line">                        + h_-&gt;value().transpose() * g_-&gt;normalAcceleration();</div><div class="line">}</div></div><!-- fragment -->
</pre><p>The function <code>processOutput</code> has a bit of complexity to allow passing a variable number of required outputs for <code>g</code> and <code>h</code> (which are thus inputs of our function). Aside from this complexity, the implementation is quite straightforward: if <code>g</code> and <code>h</code> provide both all the necessary outputs</p><ol type="1">
<li>declare these outputs as inputs of our function with the method <code>addInput</code> </li>
<li>register the update method</li>
<li>specify the dependency between the update method and the inputs (what we did not do in the previous example because we had no inputs other that the variables). This is done with <code>addInputDependency</code> </li>
<li>specify the dependency between the output and the update method.</li>
</ol>
<p>If the necessary inputs are not present, we disable the corresponding output.</p>
<pre><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Out, <span class="keyword">typename</span> Up, <span class="keyword">typename</span>... In&gt;</div><div class="line"><span class="keywordtype">void</span> FunctionDotProduct::processOutput(Out output, Up u, <span class="keywordtype">void</span> (FunctionDotProduct::*update)(), In... inputs)</div><div class="line">{</div><div class="line">  <span class="comment">// We enable the output is all the required inputs are enabled for g and h</span></div><div class="line">  <span class="keywordtype">bool</span> enableOutput = (... &amp;&amp; (g_-&gt;isOutputEnabled(inputs) &amp;&amp; h_-&gt;isOutputEnabled(inputs)));</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(enableOutput)</div><div class="line">  {</div><div class="line">    addInput(g_, inputs...);</div><div class="line">    addInput(h_, inputs...);</div><div class="line">    registerUpdates(u, update);</div><div class="line">    addInputDependency&lt;FunctionDotProduct&gt;(u, g_, inputs...);</div><div class="line">    addInputDependency&lt;FunctionDotProduct&gt;(u, h_, inputs...);</div><div class="line">    addOutputDependency&lt;FunctionDotProduct&gt;(output, u);</div><div class="line">  }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    disableOutput(output);</div><div class="line">}</div></div><!-- fragment -->
</pre><p>To check the availability of outputs on <code>g</code> and <code>h</code> with a variable number of inputs, we use <a href="https://en.cppreference.com/w/cpp/language/fold">fold expression</a> in the computation of <code>enableOutput</code>. The methods <code>addInput</code> and <code>addInputDependency</code> both accept a variable number of inputs. We use there <a href="https://en.cppreference.com/w/cpp/language/parameter_pack#Pack_expansion">parameter pack expansion</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The two first parameters of <code>processOutput</code> are template parameters to ease the writing and use of the method: for reason beyond the scope of this document, <code>Output</code> and <code>Update</code> are struct with static members mimicking enum, not enum, and the static members do not all have the same type.</dd></dl>
<h2>Example of use </h2>
<p>See <a class="el" href="a02450.html#exampleFile">Example file </a> below.</p>
<h2>Remarks </h2>
<ul>
<li>Instead of having a separate dot product for variables and functions, it would be interesting to have a single class covering both cases, as well as mixed cases (e.g. variable dot function), and to allow one of the operand be a scalar. This could be done by having several versions of the update method for the same output and registering at construction time the one adapted to the nature of the operands.</li>
<li>Update methods are expected to always compute the same values if the inputs and variables they depend on didn't change. You should not write updates that depends on internal state of your class.</li>
</ul>
<h1><a class="anchor" id="exampleFile"></a>
Example file </h1>
<p>Example of use for both functions described in this document can be found in file <code></code> <a href="https://github.com/jrl-umi3218/tvm/blob/master/examples/FunctionWritingExample.cpp">example/FunctionWritingExample.cpp</a>, in the form of test methods.</p>
<p>The first test <code>TEST_CASE("DotProduct")</code>, shows the use of the <code>DotProduct</code> function. It highlights that calling methods to access outputs, such as <code>value()</code>, do not trigger the update of these outputs. In this example, udpates are called manually. Updates are generally called automatically in TVM, but you have to pay attention to whether or not an update was called when you want to access an output yourself.</p>
<p>The second test, <code>TEST_CASE("FunctionDotProduct")</code>, showcases the <code>FunctionDotProduct</code> function. It makes use of a <code>DummyFunction</code> class which is simple an identity function whose <code>Velocity</code> output was disabled to examplify the runtime disabling of outputs in <code>FunctionDotProduct::processOutput</code>. Because <code>DummyFunction</code> does not have a <code>Velocity</code> output, the <code>Velocity</code> and <code>NormalAcceleration</code> outputs of this instance of FunctionDotProduct get disbaled.</p>
<p>In this test, to avoid tedious manual updates of the computations, we use the utility function <code>utils::generateUpdateGraph</code> to generate a computation graph that can then be run by the method <code>execute</code>.</p>
<h1>To go further </h1>
<ul>
<li>Access methods for outputs, such as <code>value</code> can be overriden in case it makes sense not to rely on a cache. This is for example the case if one wants to simply forward the result of an input function. In this particular case the link between input and ouput must be declared with <code>addDirectDependency</code>.</li>
<li>Functions in TVM are considered primarily as nodes in a computation graph, with a system of update methods and access to cache values optimized for use in solving optimization problems, but that can be counterintuitive or lack user-friendliness for manual use. The class <a class="el" href="a01905.html" title="This class wraps a function to mask the update mechanism to the user, by providing methods as value a...">tvm::utils::UpdatelessFunction</a> provides a mean to use function in a way closer to mathematical notations, where the values of the variables are specified when calling the function, e.g. <code>f.value(x,y)</code>. This is meant for ease of use, in debugging or testing context, but can incur overheads.</li>
<li>The file <a class="el" href="a00308.html">tvm/utils/checkFunction.h</a> offers several utilities to check the jacobian, velocity and normal acceleration of a function, using finite differences. </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">The TVM library</a></li>
    <li class="footer">Generated on Wed Jan 6 2021 01:58:01 for TVM by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
