<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TVM: How to write a problem</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="tvmdoxystyle.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TVM
   &#160;<span id="projectnumber">0.9.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('problemWritingExample.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">How to write a problem </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md20"></a>
Preliminaries</h1>
<div class="image">
<object type="image/svg+xml" data="problemIK.svg" style="pointer-events: none;"></object>
</div>
<p>In this tutorial, we look at how to write and solve a control problem in TVM, through an Inverse Kinematics (IK) example.</p>
<p>We consider a 2d 3-links robot, and we want to bring its end effector to a circle (see the figure above). Let's call \( q \in \mathbb{R}^3 \) the configuration of the robot, and \( g(q) \) the position of its end effector. For a given initial \( q_0 \), we are interested in computing a trajectory \( q(t) \) converging to a value where</p>
<p>\( \left\| g(q) - c \right\|^2 - r^2 = 0 \qquad (1) \)</p>
<p>where \( c \) and \( r \) are the center and radius of the circle.</p>
<p>Note that the constraint above can be rewritten equivalently by introducing an intermediate variable \( x \in \mathbb{R}^2 \), and requiring that</p>
<p>\( \begin{align} g(q) - x = 0 \qquad (2) \\ \left\| x - c \right\|^2 - r^2 = 0 \qquad (3) \end{align} \)</p>
<p>The constraint of having the end effector of a robot on a circle is very specific. So, rather than writing a dedicated function for that, and use expression (1), and for the purpose of illustrating features of TVM, we will use of formulation (2)-(3).</p>
<p>Let us note \( e_1(q,x) = g(q) - x\), \( e_2(x) = \left\| x - c \right\|^2 - r^2\) and further assume that each joint must stay within the bounds \( [-\pi/2, \pi/2]\). The target configuration must be such that</p>
<p>\( \begin{align} e_1(q) = 0 &amp; \\ e_2(q) = 0 &amp; \\ -\pi/2 \leq q_i \leq \pi/2&amp;, \ i=1..3 \end{align} \)</p>
<p>This is a static target. If we want to control the robot toward such a configuration, we need to describe how it should converge to it from a configuration that does not respect the constraints. This behavior description is what we call in TVM <em>task dynamics</em>. For the two equality constraints, we will specify the desired rate of reduction of the functions \( e_i \) with a simple proportional behavior: \( \dot{e}_i^* = -k_p e_i \). The control should then try to achieve \( \dot{e}_i = \dot{e}_i^* \). For the bounds, we will be using a <em>velocity damper</em> of the form</p>
<p>\( \begin{equation} \dot{d}^* = \left\{ \begin{array}{ll} -\xi \frac{d-d_s}{d_{int}-d_s} &amp;\mbox{if}\ d \leq d_{int}\\ -\infty &amp; \mbox{otherwise} \end{array}\right. \qquad (4) \end{equation} \)</p>
<p>for \( d \) defined as \( d_i^- = q_i + \pi/2 \) or \( d_i^+ = \pi/2 - q_i \) (see also <a class="el" href="classtvm_1_1task__dynamics_1_1VelocityDamper.html">tvm::task_dynamics::VelocityDamper</a> for more details).</p>
<p>The trajectory of \( q \) is not uniquely defined by by the above specifications (we are only constraining 2 of the 3 degrees of freedom of the robot). As an additional requirement, that would help specifying the trajectory completely, we would like to have minimal velocity. The velocity would be minimum for \( \dot{q} = 0 \). This however will have a lower priority than fulfilling the other tasks.</p>
<p>What we wish to achieve (our IK problem) is thus</p>
<p>\( \begin{align} e_1(q) = 0 &amp;,\ \ \dot{e}_1^* = -k_{p1} e_1 &amp; \mbox{(high priority)} \quad (5.a)\\ e_2(q) = 0 &amp;,\ \ \dot{e}_2^* = -k_{p2} e_2 &amp; \mbox{(high priority)} \quad (5.b)\\ -pi/2 \leq q_i \leq \pi/2&amp;,\ \ \dot{d}_i^{-*},\ \dot{d}_i^{+*} \mbox{as in (4)}, \ i=1..3 &amp; \mbox{(high priority)} \quad (5.c)\\ \dot{q} = 0 &amp; &amp; \mbox{(low priority)} \quad (5.d) \end{align} \)</p>
<p>This is the problem we will write in TVM.</p>
<p>A triplet (function, comparison to 0, task dynamics), such as \( (e_1, =, \dot{e}_1^*) \), constitutes a <em>task</em>.</p>
<p>The task dynamics chosen are specifying the desired derivative of the error functions. The instantenous (linearized) control problem we will end up solving is thus</p>
<p>\( \begin{align} \min_{\dot{q}, \dot{x}}. &amp;\ \frac{1}{2}\left\| \dot{q} \right\|^2 &amp;\quad (6)\\ \mbox{s.t.} &amp;\ \frac{\partial e_1}{\partial q}(x,q) \dot{q} + \frac{\partial e_1}{\partial x}(x,q) \dot{x} = -k_{p1} e_1(x,q)\\ &amp;\ \frac{\partial e_2}{\partial x}(x) \dot{x} = -k_{p2} e_2(x)\\ &amp;\ \dot{d}_i^{-*} \leq \dot{q}_i \leq \dot{d}_i^{+*}, \ i=1..3 \end{align} \)</p>
<p>However, we do not need to write it ourself. TVM takes care of it automatically.</p>
<p>Solving this problem for some values \( (q_k, x_k) \), we get the optimal values \( (\dot{q}^*, \dot{x}^*) \). We can then integrate with a given timestep \( dt \):</p>
<p>\( \begin{align} q_{k+1} = q_k + \dot{q}^*\\ x_{k+1} = x_k + \dot{x}^* \end{align} \)</p>
<p>The process can be repeated until convergence.</p>
<h1><a class="anchor" id="autotoc_md21"></a>
Implementation outline</h1>
<p>To define and solve the problem above, we need to the following steps</p><ol type="1">
<li>Declare and initialize the variables of our problem</li>
<li>Define the functions \( e_1 \) and \( e_2 \) (the other functions are trivial and can be written directly)</li>
<li>Write the control problem</li>
<li>Create a resolution scheme</li>
<li>Solve and integrate until convergence</li>
</ol>
<p>To define the functions, we assume that we have the following class derived from <a class="el" href="classtvm_1_1function_1_1abstract_1_1Function.html">tvm::function::abstract::Function</a>.</p><ul>
<li><code>Simple2dRobotEE</code>, which computes the end-effector position of a 2d n-link robot (i.e. the function \( g(q) \))</li>
<li><code>SphereFunction</code>, which compute the distance of a point to a sphere (that is a circle in 2d)</li>
<li><code>IdentityFunction</code>, self explanatory</li>
<li><code>DifferenceFunction</code>, which computes the difference of two functions. The implementation of these functions is not the topic of this example. The way to write functions is described in <a class="el" href="functionWritingExample.html">How to create new TVM functions.</a>.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Except for <code>IdentityFunction</code>, these functions are example functions, not part of the TVM library.</dd></dl>
<h1><a class="anchor" id="autotoc_md22"></a>
Implementation details</h1>
<dl class="section note"><dt>Note</dt><dd>In the following, the code snippet are written with the assumption of these declarations: <div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceEigen.html">Eigen</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacetvm.html">tvm</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacetvm_1_1requirements.html">tvm::requirements</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacetvm_1_1task__dynamics.html">tvm::task_dynamics</a>;</div>
<div class="line"><span class="keyword">using</span> std::make_shared;</div>
<div class="ttc" id="anamespaceEigen_html"><div class="ttname"><a href="namespaceEigen.html">Eigen</a></div><div class="ttdef"><b>Definition:</b> AffineExprDetail.h:105</div></div>
<div class="ttc" id="anamespacetvm_1_1requirements_html"><div class="ttname"><a href="namespacetvm_1_1requirements.html">tvm::requirements</a></div><div class="ttdef"><b>Definition:</b> defs.h:30</div></div>
<div class="ttc" id="anamespacetvm_1_1task__dynamics_html"><div class="ttname"><a href="namespacetvm_1_1task__dynamics.html">tvm::task_dynamics</a></div><div class="ttdef"><b>Definition:</b> defs.h:35</div></div>
<div class="ttc" id="anamespacetvm_html"><div class="ttname"><a href="namespacetvm.html">tvm</a></div><div class="ttdef"><b>Definition:</b> Clock.h:12</div></div>
</div><!-- fragment --></dd></dl>
<h2><a class="anchor" id="autotoc_md23"></a>
Variable creation</h2>
<p>Variables do not exist on their own. They are points in some mathematical spaces. To create a variable, we thus need to have a space first. The objects <a class="el" href="classtvm_1_1Space.html">tvm::Space</a> and <a class="el" href="classtvm_1_1Variable.html">tvm::Variable</a> are available through the inclusion of <code><a class="el" href="Variable_8h.html">tvm/Variable.h</a></code>. Here our variables live in Euclidean spaces ( \( \mathbb{R}^2 \) and \( \mathbb{R}^3 \)), so that simply giving the dimension of the space is enough to characterize it. Non-Euclidean manifolds can be described as well with <a class="el" href="classtvm_1_1Space.html">tvm::Space</a> (to e.g. use SO(3) or SE(3)). <a class="el" href="classtvm_1_1Space.html">tvm::Space</a> act as a factory for <a class="el" href="classtvm_1_1Variable.html">tvm::Variable</a>, requiring a name to create a variable: </p><pre><div class="fragment"><div class="line">Space R2(2);                             <span class="comment">// Creating a 2-dimensional space</span></div>
<div class="line"><a class="code" href="namespacetvm.html#a024f10de786d6592dbd271d3df847835">VariablePtr</a> x = R2.createVariable(<span class="stringliteral">&quot;x&quot;</span>);</div>
<div class="line">Space R3(3);                             <span class="comment">// Creating a 3-dimensional space</span></div>
<div class="line"><a class="code" href="namespacetvm.html#a024f10de786d6592dbd271d3df847835">VariablePtr</a> q = R3.createVariable(<span class="stringliteral">&quot;q&quot;</span>);</div>
<div class="ttc" id="anamespacetvm_html_a024f10de786d6592dbd271d3df847835"><div class="ttname"><a href="namespacetvm.html#a024f10de786d6592dbd271d3df847835">tvm::VariablePtr</a></div><div class="ttdeci">std::shared_ptr&lt; Variable &gt; VariablePtr</div><div class="ttdef"><b>Definition:</b> defs.h:65</div></div>
</div><!-- fragment --></pre><p> This is one of the only way to create variables (the other is to get a derivative or primitive of an already existing variable). <a class="el" href="classtvm_1_1Variable.html">tvm::Variable</a> keeps a copy of the <a class="el" href="classtvm_1_1Space.html">tvm::Space</a> it was created from, so there is no need to pay attention to the lifetime of the <a class="el" href="classtvm_1_1Space.html">tvm::Space</a> it was create from.</p>
<p>It is good practice to initialize the value of the variables immediately. This can be done in one of the following two ways: </p><pre><div class="fragment"><div class="line">x &lt;&lt; 0.5, 0.5;                          <span class="comment">// Eigen-like initialization</span></div>
<div class="line">q-&gt;value(Vector3d(0.4, -0.6, -0.1));    <span class="comment">// Change value through setter.</span></div>
</div><!-- fragment --></pre><h2><a class="anchor" id="autotoc_md24"></a>
Task function definitions</h2>
<p>We create the function \( e_1 \) as follows: </p><pre><div class="fragment"><div class="line"><span class="keyword">auto</span> g = make_shared&lt;Simple2dRobotEE&gt;(q, Vector2d(-3, 0), Vector3d(1, 1, 1)); <span class="comment">// g(q)</span></div>
<div class="line"><span class="keyword">auto</span> idx = make_shared&lt;function::IdentityFunction&gt;(x);                        <span class="comment">// I x</span></div>
<div class="line"><span class="keyword">auto</span> e1 = make_shared&lt;Difference&gt;(g, idx);                                    <span class="comment">// e_1(q,x) = g(q) - x</span></div>
</div><!-- fragment --></pre><p> The first line creates the function <code>g</code> computing the position of the end- effector of a robot whose configuration is given by the variable <code>q</code>, is rooted in \( (-3,0) \), and whose 3 links have unit length (<code>Vector3d(1,1,1)</code> ). <br  />
 The second line creates an identity function of the variable <code>x</code>. <br  />
 The third line defines \( e_1(q,x) = g(q) - x \). Note that <code>Difference</code> automatically detect what are its variables, no need to specify them.</p>
<p>For \( e_2 \), we take a circle with center \( c = (0, 0) \) and radius 1: </p><pre><div class="fragment"><div class="line"><span class="keyword">auto</span> e2 = make_shared&lt;SphereFunction&gt;(x, Vector2d(0, 0), 1);                  <span class="comment">// e_2(x)</span></div>
</div><!-- fragment --></pre><h2><a class="anchor" id="autotoc_md25"></a>
Writing the control problem</h2>
<p>To describe problem (5), we need to populate an instance of <a class="el" href="classtvm_1_1ControlProblem.html">tvm::ControlProblem</a>. This is done by adding tasks (<a class="el" href="classtvm_1_1Task.html">tvm::Task</a>) paired with the way we want to solve them, e.g. the level of priority, possible weights, ..., what is known in TVM as <em>solving requirements</em> and is implemented by classes found in <a class="el" href="namespacetvm_1_1requirements.html">tvm::requirements</a>. To do so, we simply use the method <a class="el" href="classtvm_1_1ControlProblem.html#ab6210225650f48069ef46d62701ff15b">tvm::ControlProblem::add</a>. <br  />
 While we can construct a <a class="el" href="classtvm_1_1Task.html">tvm::Task</a> explicitely from a triplet (function, operator, task dynamics), <a class="el" href="classtvm_1_1ControlProblem.html#ab6210225650f48069ef46d62701ff15b">tvm::ControlProblem::add</a> in conjunction with some utility functions of TVM offers a lighter syntax that we will demonstrate. </p><pre><div class="fragment"><div class="line">ControlProblem pb;</div>
<div class="line"><span class="keyword">auto</span> t1 = pb.add(e1 == 0., Proportional(2), <a class="code" href="namespacetvm_1_1requirements.html#aa5d3c61ef15897a9eee0c742a80fbee3">PriorityLevel</a>(0));</div>
<div class="line"><span class="keyword">auto</span> t2 = pb.add(e2 == 0., Proportional(2), <a class="code" href="namespacetvm_1_1requirements.html#aa5d3c61ef15897a9eee0c742a80fbee3">PriorityLevel</a>(0));</div>
<div class="line"><span class="keyword">auto</span> t3 = pb.add(-b &lt;= q &lt;= b, VelocityDamper({ 1, 0.01, 0, 0.1 }), <a class="code" href="namespacetvm_1_1requirements.html#aa5d3c61ef15897a9eee0c742a80fbee3">PriorityLevel</a>(0));</div>
<div class="line"><span class="keyword">auto</span> t4 = pb.add(<a class="code" href="namespacetvm.html#ab9c41b94c9193c6a5201468e368b838c">dot</a>(q) == 0., { <a class="code" href="namespacetvm_1_1requirements.html#aa5d3c61ef15897a9eee0c742a80fbee3">PriorityLevel</a>(1), <a class="code" href="namespacetvm_1_1requirements.html#a0bbe98ef109d5802048b074fc010ed55">AnisotropicWeight</a>(Vector3d(10,2,1)) });</div>
<div class="ttc" id="anamespacetvm_1_1requirements_html_a0bbe98ef109d5802048b074fc010ed55"><div class="ttname"><a href="namespacetvm_1_1requirements.html#a0bbe98ef109d5802048b074fc010ed55">tvm::requirements::AnisotropicWeight</a></div><div class="ttdeci">AnisotropicWeightBase&lt; true &gt; AnisotropicWeight</div><div class="ttdef"><b>Definition:</b> AnisotropicWeight.h:55</div></div>
<div class="ttc" id="anamespacetvm_1_1requirements_html_aa5d3c61ef15897a9eee0c742a80fbee3"><div class="ttname"><a href="namespacetvm_1_1requirements.html#aa5d3c61ef15897a9eee0c742a80fbee3">tvm::requirements::PriorityLevel</a></div><div class="ttdeci">PriorityLevelBase&lt; true &gt; PriorityLevel</div><div class="ttdef"><b>Definition:</b> PriorityLevel.h:33</div></div>
<div class="ttc" id="anamespacetvm_html_ab9c41b94c9193c6a5201468e368b838c"><div class="ttname"><a href="namespacetvm.html#ab9c41b94c9193c6a5201468e368b838c">tvm::dot</a></div><div class="ttdeci">VariablePtr TVM_DLLAPI dot(VariablePtr var, int ndiff=1, bool autoName=false)</div></div>
</div><!-- fragment --></pre><p> The first line create a <a class="el" href="classtvm_1_1ControlProblem.html">tvm::ControlProblem</a> instance. The last four lines are a direct transcription of (5.a) - (5.d):</p><ul>
<li>Line 2 is creating the task based on the error function \( e_1 \) that must be and equality task, with a task dynamics of type <a class="el" href="classtvm_1_1task__dynamics_1_1Proportional.html">tvm::task_dynamics::Proportional</a> whose gain \( k_p \) is 2. This task is required to be solved with a priority level of 0 (the highest priority). <dl class="section note"><dt>Note</dt><dd>The dot after the 0 in <code>e1==0.</code> is important. If absent, the compiler will attempt a pointer comparison.</dd></dl>
</li>
<li>Line 3 does exactly the same for the task based on \( e_2 \).</li>
<li>Line 4 creates the task on the bounds. Here, <code>b</code> is the vector <code>Vector3d b = Vector3d::Constant(<a class="el" href="namespacetvm_1_1constant.html#a5739e815f004bc19ad2b84be26a78824">tvm::constant::pi</a>/2);</code>. We can directly write the comparison of the variable <code>q</code> to its bounds <code>-b</code> and <code>b</code> without explicitely creating a function (more generally, linear expressions of the variables can be written directly). The task dynamics for this task is a velocity damper, whose constructor takes a tvm::task_dynamics::VelocityDamperConfig. The parameters read as follows: the first one (1) is \( d_{int}\), the second one (0.01) is \( d_s\). Since the third one is 0, the parameter \( \xi \) will be computed automatically. The fourth parameter is an offset for this automatic computation. See <a class="el" href="classtvm_1_1task__dynamics_1_1VelocityDamper.html">tvm::task_dynamics::VelocityDamper</a> and tvm::task_dynamics::VelocityDamperConfig::VelocityDamperConfig for more details. This task also needs to be solved at priority level 0.</li>
<li>Line 5 introduces the task on \( \dot{q} \). It relies on the <a class="el" href="namespacetvm.html#ab9c41b94c9193c6a5201468e368b838c">tvm::dot</a> functions which returns the time derivative of a <a class="el" href="classtvm_1_1Variable.html">tvm::Variable</a>. (dot(q,2) would return \( \ddot{q} \)). The implicit task dynamics here is that \( \dot{q}^* = 0 \), which is materialized by an instance of <a class="el" href="classtvm_1_1task__dynamics_1_1None.html">tvm::task_dynamics::None</a> that we don't need to write explicitely. This task needs to be solved at priority level 1. We also give an example of weight: here we require that the weight on minimizing the velocity of the first joint is 5 times the weight for the second joint and 10 times the weight for the third one (note the use of brackets around the list of requirements).</li>
</ul>
<p>So far, we described the problem. Now we need to specify what way we want to solve it. First, we will make a linearized version of it: </p><pre><div class="fragment"><div class="line">LinearizedControlProblem lpb(pb);</div>
</div><!-- fragment --></pre><p> <a class="el" href="classtvm_1_1ControlProblem.html">tvm::ControlProblem</a> and <a class="el" href="classtvm_1_1LinearizedControlProblem.html">tvm::LinearizedControlProblem</a> are available through the inclusion of <a class="el" href="LinearizedControlProblem_8h.html">tvm/LinearizedControlProblem.h</a>.</p>
<p>Then we choose a <em>resolution scheme</em> to solve it </p><pre><div class="fragment"><div class="line">scheme::WeightedLeastSquares solver(solver::DefaultLSSolverOptions{});</div>
</div><!-- fragment --></pre><p> Here we choose a scheme, available by inclusion of <a class="el" href="WeightedLeastSquares_8h.html">tvm/scheme/WeightedLeastSquares.h</a>, that transforms our problem into a constrained least-squares problem, where the constraints comes from the tasks at priority 0 and the objective is a sum of tasks at priority 1 (or higher, but this is out of scope) with the possible weights specified with <em>solving requirements</em>. This scheme is build by passing options which will in particular indicates the underlying solver to be used.</p>
<dl class="section note"><dt>Note</dt><dd>TVM makes the distinction between a <em>solver</em>, which is essentially a routine to solve a type of problem, and a <em>resolution scheme</em> which assembles the problem data in a specific way and call one or several solvers on them. For example, <a class="el" href="classtvm_1_1scheme_1_1WeightedLeastSquares.html">tvm::scheme::WeightedLeastSquares</a> "interprets" our <a class="el" href="classtvm_1_1LinearizedControlProblem.html">tvm::LinearizedControlProblem</a> as (6), and call one of the possible QP solvers as specified by the options chosen.</dd></dl>
<p>By including <a class="el" href="defaultLeastSquareSolver_8h.html">tvm/solver/defaultLeastSquareSolver.h</a>, and using <a class="el" href="classtvm_1_1solver_1_1DefaultLSSolverOptions.html">tvm::solver::DefaultLSSolverOptions</a> (or <a class="el" href="classtvm_1_1solver_1_1DefaultLSSolverFactory.html">tvm::solver::DefaultLSSolverFactory</a>) we are choosing the first available solver supported by TVM (see the header for more details on which solver get chosen). If you want to choose a specific solver, you can simply include its header and choose the corresponding option. For example, QLD is available by including tvm/solver/QLDLeastSqaureSolver.h and using <a class="el" href="classtvm_1_1solver_1_1QLDLSSolverOptions.html">tvm::solver::QLDLSSolverOptions</a>. Choosing a specific solver offers more fine control with the options.</p>
<p>Now, we can just do <code>solver.solve(lpb)</code>. The variables of our problem have been automatically detected as being \( \dot{x} \) and \( \dot{q} \). Their counterpart in the code are <code>dot(x)</code> and <code>dot(q)</code>, whose value after the call to <code>solve</code> are containing the solution of the problem.</p>
<p>If we consider as a stopping criterion for the IK that we should have \( \left\| \dot{x} \right\| \leq 10^{-8} \) and \( \left\| \dot{q} \right\| \leq 10^{-8} \), then we can write the IK as </p><pre><div class="fragment"><div class="line"><span class="keywordflow">do</span></div>
<div class="line">{</div>
<div class="line">  solver.solve(lpb);</div>
<div class="line">  x-&gt;value(x-&gt;value() + <a class="code" href="namespacetvm.html#ab9c41b94c9193c6a5201468e368b838c">dot</a>(x)-&gt;value() * dt);</div>
<div class="line">  q-&gt;value(q-&gt;value() + <a class="code" href="namespacetvm.html#ab9c41b94c9193c6a5201468e368b838c">dot</a>(q)-&gt;value() * dt);</div>
<div class="line">} <span class="keywordflow">while</span> (<a class="code" href="namespacetvm.html#ab9c41b94c9193c6a5201468e368b838c">dot</a>(q)-&gt;value().norm() &gt; 1e-8 || <a class="code" href="namespacetvm.html#ab9c41b94c9193c6a5201468e368b838c">dot</a>(x)-&gt;value().norm() &gt; 1e-8);</div>
</div><!-- fragment --></pre><p> with <code>dt</code> the value of the time step for integration (taken here as 0.1).</p>
<p>This is the total code for this example: </p><pre> 
<div class="fragment"><div class="line">VectorXd IKExample()</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Creating variable x in R^2 and initialize it to [0.5, 0.5]</span></div>
<div class="line">  Space R2(2);</div>
<div class="line">  <a class="code" href="namespacetvm.html#a024f10de786d6592dbd271d3df847835">VariablePtr</a> x = R2.createVariable(<span class="stringliteral">&quot;x&quot;</span>);</div>
<div class="line">  x &lt;&lt; 0.5, 0.5;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Creating variable q in R^3 and initialize it to [0.4, -0.6, -0.1]</span></div>
<div class="line">  Space R3(3);</div>
<div class="line">  <a class="code" href="namespacetvm.html#a024f10de786d6592dbd271d3df847835">VariablePtr</a> q = R3.createVariable(<span class="stringliteral">&quot;q&quot;</span>);</div>
<div class="line">  q-&gt;set(Vector3d(0.4, -0.6, -0.1));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Creating the functions</span></div>
<div class="line">  <span class="keyword">auto</span> g = make_shared&lt;Simple2dRobotEE&gt;(q, Vector2d(-3, 0), Vector3d(1, 1, 1)); <span class="comment">// g(q)</span></div>
<div class="line">  <span class="keyword">auto</span> idx = make_shared&lt;function::IdentityFunction&gt;(x);                        <span class="comment">// I x</span></div>
<div class="line">  <span class="keyword">auto</span> e1 = make_shared&lt;Difference&gt;(g, idx);                                    <span class="comment">// e_1(q,x) = g(q) - x</span></div>
<div class="line">  <span class="keyword">auto</span> e2 = make_shared&lt;SphereFunction&gt;(x, Vector2d(0, 0), 1);                  <span class="comment">// e_2(x)</span></div>
<div class="line"> </div>
<div class="line">  Vector3d b = Vector3d::Constant(<a class="code" href="namespacetvm_1_1constant.html#a5739e815f004bc19ad2b84be26a78824">tvm::constant::pi</a> / 2);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Creating the problem</span></div>
<div class="line">  ControlProblem pb;</div>
<div class="line">  <span class="keyword">auto</span> t1 = pb.add(e1 == 0., Proportional(2), <a class="code" href="namespacetvm_1_1requirements.html#aa5d3c61ef15897a9eee0c742a80fbee3">PriorityLevel</a>(0));</div>
<div class="line">  <span class="keyword">auto</span> t2 = pb.add(e2 == 0., Proportional(2), <a class="code" href="namespacetvm_1_1requirements.html#aa5d3c61ef15897a9eee0c742a80fbee3">PriorityLevel</a>(0));</div>
<div class="line">  <span class="keyword">auto</span> t3 = pb.add(-b &lt;= q &lt;= b, VelocityDamper({1, 0.01, 0, 0.1}), <a class="code" href="namespacetvm_1_1requirements.html#aa5d3c61ef15897a9eee0c742a80fbee3">PriorityLevel</a>(0));</div>
<div class="line">  <span class="keyword">auto</span> t4 = pb.add(<a class="code" href="namespacetvm.html#ab9c41b94c9193c6a5201468e368b838c">dot</a>(q) == 0., {<a class="code" href="namespacetvm_1_1requirements.html#aa5d3c61ef15897a9eee0c742a80fbee3">PriorityLevel</a>(1), <a class="code" href="namespacetvm_1_1requirements.html#a0bbe98ef109d5802048b074fc010ed55">AnisotropicWeight</a>(Vector3d(10, 2, 1))});</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Linearization</span></div>
<div class="line">  LinearizedControlProblem lpb(pb);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Creating the resolution scheme</span></div>
<div class="line">  scheme::WeightedLeastSquares solver(solver::DefaultLSSolverOptions{});</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// IK loop</span></div>
<div class="line">  <span class="keywordtype">int</span> i = 0;</div>
<div class="line">  <span class="keywordflow">do</span></div>
<div class="line">  {</div>
<div class="line">    solver.solve(lpb);</div>
<div class="line">    x-&gt;set(x-&gt;value() + <a class="code" href="namespacetvm.html#ab9c41b94c9193c6a5201468e368b838c">dot</a>(x)-&gt;value() * dt);</div>
<div class="line">    q-&gt;set(q-&gt;value() + <a class="code" href="namespacetvm.html#ab9c41b94c9193c6a5201468e368b838c">dot</a>(q)-&gt;value() * dt);</div>
<div class="line">    ++i;</div>
<div class="line">  } <span class="keywordflow">while</span>((<a class="code" href="namespacetvm.html#ab9c41b94c9193c6a5201468e368b838c">dot</a>(q)-&gt;value().norm() &gt; 1e-8 || <a class="code" href="namespacetvm.html#ab9c41b94c9193c6a5201468e368b838c">dot</a>(x)-&gt;value().norm() &gt; 1e-8) &amp;&amp; i &lt; maxIt);</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;At q = &quot;</span> &lt;&lt; q-&gt;value().transpose() &lt;&lt; <span class="stringliteral">&quot;,\n    e1 = &quot;</span> &lt;&lt; e1-&gt;value().transpose() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span></div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot;   convergence in &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; iterations&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> q-&gt;value();</div>
<div class="ttc" id="anamespacetvm_1_1constant_html_a5739e815f004bc19ad2b84be26a78824"><div class="ttname"><a href="namespacetvm_1_1constant.html#a5739e815f004bc19ad2b84be26a78824">tvm::constant::pi</a></div><div class="ttdeci">constexpr double pi</div><div class="ttdef"><b>Definition:</b> defs.h:107</div></div>
<div class="line">}</div>
</div><!-- fragment --></pre><h2><a class="anchor" id="autotoc_md26"></a>
Remarks</h2>
<ul>
<li>We never have to define an optimization variable as an aggregate of \( \dot{x} \) and \( \dot{q} \). This is done automatically and internally by TVM. The user just need to manipulate the variables independently, including to retrieve the solution.</li>
<li>In the definition of a task, the right hand side of the comparison operator (e.g. <code>==</code> in the first task) need not be 0. It can be any scalar or vector with the correct dimension (a scalar is interpreted as a vector with the same dimension as the left hand side and whose elements are all equal to the scalar). For example, if we wanted the robot end-effector to go to [-1;1] we could simply write <code>g == Vector2d(-1,1)</code>.</li>
<li>As a shortcut, we can directly declare <code>pb</code> to be a <a class="el" href="classtvm_1_1LinearizedControlProblem.html">tvm::LinearizedControlProblem</a> and use the <code>add</code> method on it.</li>
<li>If you want to see the matrices and vectors assembled by <code>solver</code>, you can pass <code>solver::DefaultLSSolverOptions().verbose(true)</code> at its creation.</li>
<li>Thanks to our introduction of the variable \( x \), it is easy to change the shape we want the robot end-effector to reach. For example, \( x \) could be constrained on a line \( n^t x = a \). This can be done by simply replacing <code>e2==0</code>. by <code>n.transpose()</code> * x == a with <code>n</code> a Eigen::VectorXd and <code>a</code> a <code>double</code>.</li>
</ul>
<h1><a class="anchor" id="autotoc_md27"></a>
To go further</h1>
<h2><a class="anchor" id="autotoc_md28"></a>
Substitutions</h2>
<p>The introduction of the variable \( x \) is useful to write the problem simply, without having to implement a specific function for our particular example. But it also makes the problem bigger, and that could be a concern for computation time.</p>
<p>However, the variable \( x \) appears in a very simple way in \( e_1 \), and thus in the linearization of problem (6), \( \frac{\partial e_1}{\partial q}(x,q) \dot{q} + \frac{\partial e_1}{\partial x}(x,q) \dot{x} = -k_{p1} e_1(x,q) \), \( \frac{\partial e_1}{\partial x}(x,q) \) is simply \( -I \), i.e. there is a simple way to express \( \dot{x} \) from \( \dot{q} \) and the other quantities of the problem.</p>
<p>We can tell the scheme that it can use the constraint derived from the task \( e_1 \), to pre-solve the problem in \( \dot{x} \) by adding </p><pre><div class="fragment"><div class="line">lpb.add(hint::Substitution(lpb.constraint(t1.get()), <a class="code" href="namespacetvm.html#ab9c41b94c9193c6a5201468e368b838c">dot</a>(x)));</div>
</div><!-- fragment --></pre><p> Doing so, the scheme will reduce the problem to an optimization on \( \dot{q} \) only, by susbtituting \( \dot{x} \) by the expression deduced from the specified constraint. After solving the reduced problem, the value of \( \dot{x} \) is computed as well. In the end the problem solved will be exactly the same as what we would have got by implementing manually the equation (1), <em>i.e</em>. a composition of <code>Simple2dRobotEE</code> and <code>SphereFunction</code>, but it was obtained with less coding and in a more generic way.</p>
<p>Substitutions are working when the matrix in front of the variable to substitute is not simple, and even if the matrix is not invertible. But they are useful only when the matrix has a structure or properties that could help speed up the computations. Otherwise, using them is at best not necessary and could even degrade the performance of the resolution.</p>
<h2><a class="anchor" id="autotoc_md29"></a>
Formulation in acceleration</h2>
<p>So far, we have used task dynamics of <em>order</em> one (or zero for the velocity task), and thus the variables were automatically deduced to be \( \dot{x} \) and \( \dot{q} \). We may want to use task dynamics of order two instead, in which case the linearized problem will have \( \ddot{x} \) and \( \ddot{q} \) as variable. This can be done by changing the definition of the control problem e.g. </p><pre><div class="fragment"><div class="line"><span class="keyword">auto</span> t1 = pb.add(e1 == 0., ProportionalDerivative(50), <a class="code" href="namespacetvm_1_1requirements.html#aa5d3c61ef15897a9eee0c742a80fbee3">PriorityLevel</a>(0));</div>
<div class="line"><span class="keyword">auto</span> t2 = pb.add(e2 == 0., ProportionalDerivative(50), <a class="code" href="namespacetvm_1_1requirements.html#aa5d3c61ef15897a9eee0c742a80fbee3">PriorityLevel</a>(0));</div>
<div class="line"><span class="keyword">auto</span> t3 = pb.add(-b &lt;= q &lt;= b, VelocityDamper(dt, { 1., 0.01, 0, 0.1 }), <a class="code" href="namespacetvm_1_1requirements.html#aa5d3c61ef15897a9eee0c742a80fbee3">PriorityLevel</a>(0));</div>
<div class="line"><span class="keyword">auto</span> t4 = pb.add(<a class="code" href="namespacetvm.html#ab9c41b94c9193c6a5201468e368b838c">dot</a>(q, 2) == 0., { <a class="code" href="namespacetvm_1_1requirements.html#aa5d3c61ef15897a9eee0c742a80fbee3">PriorityLevel</a>(1), <a class="code" href="namespacetvm_1_1requirements.html#a0bbe98ef109d5802048b074fc010ed55">AnisotropicWeight</a>(Vector3d(10,2,1)) });</div>
</div><!-- fragment --></pre><p> The rest of the code is left unchanged, but for the need to initialize the values of \( \dot{x} \) and \( \dot{q} \), and to perform the integration from \( \ddot{x} \) and \( \ddot{q} \).</p>
<h2><a class="anchor" id="autotoc_md30"></a>
Example file</h2>
<p><a href="https://github.com/jrl-umi3218/tvm/blob/master/examples/ProblemWritingExample.cpp">example/ProblemWritingExample.cpp</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">The TVM library</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
